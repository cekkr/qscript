Here is the complete **PsiScript v1.1 Technical Reference Manual**.

This document updates the semantic definition of the language. It retains the syntax found in `PsiScript-Definition.md` and `qft_3.psi` but reframes the *meaning* of the operations. It moves away from low-level geometric rotations and towards the high-level concept of **Interference Sculpting**, addressing the conceptual gap regarding exponential scaling and the role of imaginary numbers.

-----

# PsiScript v1.1 - Technical Reference Manual

## 1\. Philosophy: The Sculpting Paradigm

PsiScript is a high-level quantum description language designed to abstract the complexity of matrix algebra into a logical process of **data sculpting**.

Unlike classical programming, which constructs a solution by iterating through data, PsiScript operates by **filtering the universe of possibilities**.

  * **The Medium:** A high-dimensional Hilbert space (the register) representing every possible combination of states simultaneously.
  * **The Tool:** Complex numbers (imaginary phases) act as the "chisel."
  * **The Mechanism:** Constructive and Destructive Interference.

In v1.1, we move beyond the concept of "spinning qubits." We visualize algorithms as creating a massive block of data (Superpose) and carving away the incorrect answers (Phase + Reflect) until only the solution remains.

-----

## 2\. Syntax Overview

The syntax remains declarative and distinct between Quantum-Time (manipulating the wave function) and Classical-Time (control flow).

```psi
// Declaration: Creates a Multi-Dimensional Hyperspace (Register)
let q = Register(3) 

// 1. EXPANSION: Initialize the search space
q.Superpose(targets: ALL)

// 2. THE CHISEL: Mark states conceptually using logic
// This effectively "tags" specific indices in the 2^N space
q.Phase(angle: PI, where: q[0] == q[1])

// 3. INTERFERENCE: Convert tags into probability shifts
q.Reflect(axis: MEAN)

// 4. COLLAPSE: Extract the surviving reality
let result = Measure(q[0])
```

**Core Rules:**

  * **`let reg = Register(N)`**: Instantiates a computational space of $2^N$ dimensions.
  * **`where:`**: A **quantum predicate**. It does not check a single variable; it acts as a filter across the entire superposition simultaneously.
  * **`Measure`**: The irreversible boundary. It collapses the wave function from complex amplitudes to classical bits.

-----

## 3\. Semantic Definition of Primitives

### 3.1 `Superpose(targets)` — The Expansion

  * **Syntax:** `Register.Superpose(targets: ALL | [i, ...])`
  * **Semantic Meaning:**
    Initializes the **Search Space**. Regardless of whether the register has 3 qubits or 50, this command instantiates every possible integer state ($0$ to $2^N-1$) simultaneously with equal potential. It creates the "block of marble" from which the answer will be carved.
  * **Scaling Intuition:**
      * 3 qubits = 8 parallel realities.
      * 30 qubits = 1 billion parallel realities.
      * This operation maximizes the entropy of the system.

### 3.2 `Phase(angle, where)` — The Chisel (Logical Etching)

  * **Syntax:** `Register.Phase(angle: Angle, where: Predicate)`
  * **Semantic Meaning:**
    This is the primary logical operator. It uses **Complex Numbers** to "tag" specific regions of the hyperspace without destroying them yet.
      * **The Role of Imaginary Numbers:** By applying a phase (e.g., $\pi, \pi/2$), you rotate the state's value into the imaginary plane.
      * **Tagging for Deletion:** If `angle: PI`, you are marking the states satisfying the `where` condition as "invalid" (assigning a negative amplitude).
      * [cite_start]**Tagging for Frequency:** If `angle: PI/2` (as seen in QFT), you are encoding frequency data into the relative phase between states[cite: 3].
  * **Circuit Reality:**
    Physically, this compiles to Controlled-Phase gates (CZ, CP), but conceptually, it is a **Logical Marker**.

### 3.3 `Reflect(axis)` — The Interference Trigger

  * **Syntax:** `Register.Reflect(axis: Axis.MEAN)`
  * **Semantic Meaning:**
    This command converts the "Phase Tags" into actual **Probability Shifts**. It forces the wave function to interfere with itself.
      * **Destructive Interference:** States marked with conflicting phases (by previous `Phase` commands) cancel each other out.
      * **Constructive Interference:** States with aligned phases amplify.
  * **The "Sculpting" Effect:**
    This is where the "wrong" answers (tagged previously) are physically removed from the probability distribution, leaving the solution peak visible.

### 3.4 `Flip(target, where, when)` — The Pivot

  * **Syntax:** `Register.Flip(target: i, where: Predicate)`
  * **Semantic Meaning:**
    Reorients the subspace. In a high-dimensional context, this acts as a conditional index shifter.
      * **Quantum Guard (`where`):** Creates entanglement. It links the state of one dimension to another (e.g., "If dimension X is active, flip dimension Y").
      * [cite_start]**Usage in Networking:** As seen in QFT, this is used to reverse the bit order or swap data between subspaces[cite: 6].

-----

## 4\. Scaling: From 3 Qubits to N Qubits

The power of PsiScript lies in the fact that the code does not grow with the data size. A single semantic instruction operates on the exponential volume of the register.

**The "Implicit" Complexity:**
In classical code, iterating a million items requires a loop 1,000,000 times long. In PsiScript, the `where` clause implies a parallel check on all $2^N$ states instantly.

> **Note:** The "Precision" of a quantum algorithm is not defined by how many qubits you use, but by how accurately your `Phase` instructions can isolate the single correct state within the massive noise of the `Superpose`.

-----

## 5\. Practical Examples (v1.1)

### 5.1 The Frequency Analyzer (QFT)

This example demonstrates using `Phase` not to delete data, but to encode frequency relationships (The Fourier Transform).

```psi
// [Ref: qft_3.psi]
let q = Register(3)

// 1. EXPANSION: Prepare the signal space
q.Superpose(targets: ALL) // Implicit in input preparation

// 2. THE CHISEL (Frequency Encoding):
// We apply smaller and smaller cuts (PI/2, PI/4) to encode the 
// binary fraction of the phase.
// This is not "rotation"; this is establishing a precise relationship 
// between the bits to capture the periodicity of the data.

// Most Significant Bit processing
q.Superpose(targets: 0) 
[cite_start]q.Phase(angle: PI/2, where: q[0] == 1 && q[1] == 1) // Coarse tuning [cite: 2]
[cite_start]q.Phase(angle: PI/4, where: q[0] == 1 && q[2] == 1) // Fine tuning [cite: 3]

// Middle Bit processing
q.Superpose(targets: 1)
[cite_start]q.Phase(angle: PI/2, where: q[1] == 1 && q[2] == 1) // Coarse tuning relative to Q2 [cite: 4]

// Least Significant Bit processing
q.Superpose(targets: 2)

// 3. THE PIVOT (Reordering):
// The math leaves the result bit-reversed. We pivot the data back.
[cite_start]q.Flip(target: 0, where: q[2] == 1) // Swap Q0 and Q2 logic [cite: 6]
[cite_start]q.Flip(target: 2, where: q[0] == 1) // Completing the swap [cite: 7]
```

### 5.2 The Needle in the Haystack (Grover)

This example demonstrates the "Sculpting" workflow: Tagging and Removing.

```psi
// 1. DEFINITION: A database of 1 Million entries (20 qubits)
let db = Register(20)

// 2. EXPANSION: Create the block of marble
db.Superpose(targets: ALL)

// 3. THE SCULPTING LOOP
// We don't loop to "search"; we loop to "sharpen" the interference.
for (i in 0..800) {
    // A. THE CHISEL: Tag the target (e.g., ID 777) with a negative phase
    db.Phase(angle: PI, where: db == 777)
    
    // B. THE HAMMER: Invert around the mean to delete non-tagged items
    db.Reflect(axis: MEAN)
}

// 4. OBSERVE
let result = Measure(db)
```