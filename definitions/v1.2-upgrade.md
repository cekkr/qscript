Here is the updated language definition for **PsiScript v1.2**.

This update introduces the **"Zoom" Philosophy**: You can stay at the high level to sculpt probability amplitudes (Logic Layer), or "zoom in" to the physical timeline to craft the electromagnetic waves that drive the rotation (Pulse Layer).

To satisfy your requirement for "visualizable flow," v1.2 treats Pulse operations not just as raw signals, but as **geometric vectors applied over time**.

-----

# PsiScript v1.2 - Hybrid Reference Manual

## 1\. Philosophy: Geometric Duality

v1.2 bridges the gap between the **Mathematician** (who sees Hilbert spaces) and the **Engineer** (who sees microwave pulses).

  * **Macro View (The Sculptor):** Manipulate interference, logical entanglement, and phase (as in v1.1).
  * **Micro View (The Composer):** Define *how* a rotation occurs physically. Instead of instant "gates," we see **Trajectories**.
  * **Visual Flow:** The code structure mimics the circuit lines. Blocks of code represent time-aligned operations.

-----

## 2\. The Hybrid Syntax

We introduce the `Analog` scope. This is a "trapdoor" that suspends the abstract rules of logic-time and enters physical-time.

```psi
// 1. High-Level Abstraction (Logic Layer)
// "Make these states interfere"
let q = Register(2)
q.Superpose(targets: ALL)
q.Phase(angle: PI, where: q[0] == q[1])

// 2. Hybrid Injection (Pulse Layer)
// "Zoom in on q[0] to apply a custom error-correction sequence"
Analog(target: q[0]) {
    // Define flow using geometric directions and durations
    Rotate(axis: X, angle: PI/2, duration: 20ns, shape: Gaussian(sigma: 4ns))
    Wait(10ns) // Buffer time
    Rotate(axis: -X, angle: PI/2, duration: 20ns, shape: Drag(beta: 0.5))
}

// 3. Return to High Level
q.Reflect(axis: Axis.MEAN)
```

-----

## 3\. Visualizing "Flow" & Directions

To keep the code "visualizable" as a circuit, v1.2 adopts a **Directional Syntax** for pulses. Instead of abstract math matrices, we use geometric movements.

### 3.1 The `Rotate` Primitive

Replaces abstract gates with physical movements on the Bloch Sphere.

  * **Syntax:** `Rotate(axis: Vector, angle: Float, duration: Time, shape: Waveform)`
  * **Visual Intuition:** Imagine the qubit vector physically dragging across the sphere surface. The `shape` defines the velocity profile of that movement.

### 3.2 The `Align` Block (Parallel Flow)

In a quantum circuit, parallel lines mean simultaneous actions. PsiScript captures this with `Align`.

```psi
// Visualizing two wires acting simultaneously
Align {
    // Wire 1: q[0] does a slow rotation
    branch q[0] {
        Rotate(axis: Z, angle: PI, duration: 100ns)
    }
    
    // Wire 2: q[1] does a fast echo sequence
    branch q[1] {
        Rotate(axis: X, angle: PI, duration: 40ns)
        Wait(20ns)
        Rotate(axis: -X, angle: PI, duration: 40ns)
    }
} // Both branches finish together at the longest duration
```

-----

## 4\. Pulse-Level Semantics

When inside an `Analog` block, the rules change to allow precision:

1.  **No `where` Predicates:** You cannot condition a pulse on a superposition. You are driving the physical line.
2.  **Explicit Timing:** Time is measured in `ns` (nanoseconds) or `dt` (hardware cycles), not logical steps.
3.  **Frame Tracking:** You must manage the reference frame.
      * `ShiftPhase(angle)`: Instantaneous virtual Z-rotation (frame update).
      * `SetFreq(hz)`: Change the drive frequency (e.g., for accessing different energy levels).

### New Primitives (Micro-Level)

  * `Play(waveform, channel)`: The rawest command. Plays an arbitrary complex wave.
  * `Acquire(duration, kernel)`: Raw readout of the microwave resonator (for custom measurement classification).

-----

## 5\. Bridging the Gap: Custom Gates

The most powerful feature of v1.2 is defining **Pulse Implementations for Logic Verbs**. This allows you to build your own high-performance gates and use them with the high-level `where` syntax.

```psi
// Definition: "Here is how to physically perform a 'SoftFlip'"
def pulse SoftFlip(target: Qubit) {
    Analog(target) {
        // A specific pulse shape that minimizes leakage
        Rotate(axis: X, angle: PI, shape: Slepian(window: 0.3))
    }
}

// Usage: "Apply SoftFlip logic to the superposition"
let reg = Register(3)
// The compiler substitutes your pulse schedule into the logic flow
reg.apply(SoftFlip, where: reg[0] && !reg[1]) 
```

-----

## 6\. Example: The "Ghost" Filter

This example creates a custom interaction that cancels errors using a "Dynamical Decoupling" pulse sequence, visualized as a geometric flow.

```psi
let memory = Register(1)

// Initialize
memory.Superpose(targets: ALL)

// Visual Flow: The qubit 'idles' while we apply geometric echoes to keep it alive
Align {
    // The "Main Line" - Logic
    branch memory {
        // We define a physical wait with active noise cancellation
        Analog(target: memory[0]) {
            // Visualize: Top -> Bottom -> Top (Canceling noise)
            Rotate(axis: Y, angle: PI, duration: 20ns) // Pulse 1
            Wait(50ns)                                 // Free evolution
            Rotate(axis: -Y, angle: PI, duration: 20ns)// Pulse 2 (Echo)
        }
    }
}

// Measurement
let result = Measure(memory)
```

## Summary of Changes from v1.1

| Feature | v1.1 (Logic Only) | v1.2 (Hybrid) |
| :--- | :--- | :--- |
| **Time** | Logical Steps (Depth) | Physical Duration (`ns`, `dt`) |
| **Operations** | `Phase`, `Flip`, `Reflect` | `Rotate`, `Play`, `ShiftPhase` |
| **Control** | `where:` (Entanglement) | `Analog { ... }` (Direct Drive) |
| **Visuals** | Set Theory (Venn Diagrams) | Geometry (Sphere Rotations & Time Lines) |